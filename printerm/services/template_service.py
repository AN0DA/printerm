"""Template service implementation."""

import datetime
import logging
import os
import textwrap
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from printerm.services.interfaces import ConfigService

import yaml
from jinja2 import BaseLoader, Environment
from mistune import Markdown
from unidecode import unidecode

from printerm.exceptions import TemplateError
from printerm.printing.markdown_renderer import PrinterRenderer

logger = logging.getLogger(__name__)

PRINT_TEMPLATE_FOLDER = os.path.join(os.path.dirname(os.path.realpath(__file__)), "..", "templates", "print_templates")


class TemplateServiceImpl:
    """Template service implementation."""

    def __init__(
        self, template_dir: str = PRINT_TEMPLATE_FOLDER, config_service: "ConfigService | None" = None
    ) -> None:
        self.template_dir = template_dir
        self.config_service = config_service
        self.templates: dict[str, dict[str, Any]] = {}
        self.load_templates()

    def load_templates(self) -> None:
        """Load all templates from the template directory."""
        try:
            self.templates = {}
            if not os.path.exists(self.template_dir):
                raise TemplateError(f"Template directory not found: {self.template_dir}")

            for filename in os.listdir(self.template_dir):
                if filename.endswith(".yaml"):
                    path = os.path.join(self.template_dir, filename)
                    try:
                        with open(path, encoding="utf-8") as file:
                            template = yaml.safe_load(file)
                            key = os.path.splitext(filename)[0]
                            self.templates[key] = template
                    except Exception as e:
                        logger.warning(f"Failed to load template {filename}: {e}")
        except Exception as e:
            raise TemplateError("Failed to load templates", str(e)) from e

    def get_template(self, name: str) -> dict[str, Any]:
        """Get a template by name."""
        template = self.templates.get(name)
        if not template:
            raise TemplateError(f"Template '{name}' not found")
        return template

    def list_templates(self) -> list[str]:
        """List all available template names."""
        return list(self.templates.keys())

    def render_template(self, template_name: str, context: dict[str, Any]) -> list[dict[str, Any]]:
        """Render a template with the given context."""
        template = self.get_template(template_name)

        # Get configuration settings
        chars_per_line = 32
        enable_special_letters = False

        if self.config_service:
            chars_per_line = self.config_service.get_chars_per_line()
            enable_special_letters = self.config_service.get_enable_special_letters()

        segments = template.get("segments", [])
        rendered_segments = []
        env = Environment(loader=BaseLoader(), autoescape=True, keep_trailing_newline=True)

        try:
            for segment in segments:
                template_text = segment["text"]
                jinja_template = env.from_string(template_text)

                try:
                    text = jinja_template.render(**context)
                except Exception as e:
                    raise TemplateError(f"Error rendering template '{template_name}'", str(e)) from e

                if not enable_special_letters:
                    logger.debug("Transliterating text to ASCII")
                    text = unidecode(text)

                if segment.get("markdown", False):
                    # Use Mistune to parse markdown and render segments
                    renderer = PrinterRenderer(chars_per_line)
                    markdown = Markdown(renderer=renderer)
                    markdown(text)

                    # Process the segments generated by the renderer
                    for seg in renderer.segments:
                        wrapped_text = textwrap.fill(
                            seg["text"], width=chars_per_line, replace_whitespace=False, drop_whitespace=False
                        )
                        styles = seg.get("styles", {})
                        rendered_segments.append({"text": wrapped_text, "styles": styles})
                else:
                    wrapped_text = textwrap.fill(
                        text, width=chars_per_line, replace_whitespace=False, drop_whitespace=False
                    )
                    rendered_segments.append({"text": wrapped_text, "styles": segment.get("styles", {})})

            return rendered_segments
        except Exception as e:
            if isinstance(e, TemplateError):
                raise
            raise TemplateError(f"Failed to render template '{template_name}'", str(e)) from e


def compute_agenda_variables() -> dict[str, Any]:
    """Compute variables for agenda template."""
    today = datetime.date.today()
    _, week_number, _ = today.isocalendar()
    week_start = today - datetime.timedelta(days=today.weekday())
    week_end = week_start + datetime.timedelta(days=6)
    days = []
    for i in range(7):
        day_date = week_start + datetime.timedelta(days=i)
        day_name = day_date.strftime("%A")
        date_str = day_date.strftime("%Y-%m-%d")
        days.append({"day_name": day_name, "date": date_str})
    return {
        "week_number": week_number,
        "week_start_date": week_start.strftime("%Y-%m-%d"),
        "week_end_date": week_end.strftime("%Y-%m-%d"),
        "days": days,
    }
