import datetime
import logging
import textwrap
from typing import Any

import requests
from jinja2 import BaseLoader, Environment
from mistune import Markdown
from packaging import version
from unidecode import unidecode

from printerm.core.config import get_chars_per_line, get_enable_special_letters
from printerm.printing.markdown_renderer import PrinterRenderer
from printerm.templates.template_manager import TemplateManager

logger = logging.getLogger(__name__)


class TemplateRenderer:
    """
    Renders templates with context, handling Markdown formatting,
    text wrapping, and special character processing.
    """

    def __init__(self, template_manager: TemplateManager) -> None:
        self.template_manager = template_manager
        self.reload_settings()
        logging.debug("Initialized TemplateRenderer.")

    def reload_settings(self) -> None:
        """
        Reload settings from the configuration.
        """
        self.chars_per_line = get_chars_per_line()
        self.enable_special_letters = get_enable_special_letters()
        logging.debug("TemplateRenderer settings reloaded.")

    def render_from_template(self, template_name: str, context: dict[str, Any]) -> list[dict[str, Any]]:
        """
        Render the template with context, handling markdown formatting and special characters.
        """
        template = self.template_manager.get_template(template_name)
        if not template:
            raise ValueError(f"Template '{template_name}' not found.")

        segments = template.get("segments", [])
        rendered_segments = []
        env = Environment(loader=BaseLoader(), autoescape=True, keep_trailing_newline=True)

        for segment in segments:
            template_text = segment["text"]
            jinja_template = env.from_string(template_text)
            try:
                text = jinja_template.render(**context)
            except Exception as e:
                logger.error(f"Error rendering template '{template_name}': {e}")
                raise

            if not self.enable_special_letters:
                logger.debug("Transliterating text to ASCII")
                text = unidecode(text)

            if segment.get("markdown", False):
                # Use Mistune to parse markdown and render segments
                renderer = PrinterRenderer(self.chars_per_line)
                markdown = Markdown(renderer=renderer)
                markdown(text)

                # Process the segments generated by the renderer
                for seg in renderer.segments:
                    wrapped_text = textwrap.fill(
                        seg["text"], width=self.chars_per_line, replace_whitespace=False, drop_whitespace=False
                    )
                    styles = seg.get("styles", {})
                    rendered_segments.append({"text": wrapped_text, "styles": styles})
            else:
                wrapped_text = textwrap.fill(
                    text, width=self.chars_per_line, replace_whitespace=False, drop_whitespace=False
                )
                rendered_segments.append({"text": wrapped_text, "styles": segment.get("styles", {})})

        return rendered_segments


def compute_agenda_variables() -> dict[str, Any]:
    today = datetime.date.today()
    _, week_number, _ = today.isocalendar()
    week_start = today - datetime.timedelta(days=today.weekday())
    week_end = week_start + datetime.timedelta(days=6)
    days = []
    for i in range(7):
        day_date = week_start + datetime.timedelta(days=i)
        day_name = day_date.strftime("%A")
        date_str = day_date.strftime("%Y-%m-%d")
        days.append({"day_name": day_name, "date": date_str})
    return {
        "week_number": week_number,
        "week_start_date": week_start.strftime("%Y-%m-%d"),
        "week_end_date": week_end.strftime("%Y-%m-%d"),
        "days": days,
    }


def get_latest_version() -> str:
    """Get the latest version of printerm from PyPI."""
    url = "https://pypi.org/pypi/printerm/json"
    try:
        response = requests.get(url, timeout=5)
        if response.status_code == 200:
            data = response.json()
            return data["info"]["version"]
        else:
            logger.warning(f"Failed to fetch the latest version from PyPI: {response.status_code}")
            raise RuntimeWarning("Failed to fetch the latest version from PyPI.")
    except Exception as e:
        logger.error(f"Error while fetching latest version: {e}")
        raise RuntimeWarning(f"Failed to fetch the latest version from PyPI: {e}") from e


def is_new_version_available(current_version: str) -> bool:
    """Check if a newer version is available on PyPI."""
    try:
        latest_version = get_latest_version()
        return version.parse(latest_version) > version.parse(current_version)
    except Exception as e:
        logger.error(f"Error checking for updates: {e}")
        return False
