import logging
import textwrap
from typing import Any

import requests
from jinja2 import BaseLoader, Environment
from mistune import Markdown
from packaging import version
from unidecode import unidecode

from printerm.core.config import get_chars_per_line, get_enable_special_letters
from printerm.printing.markdown_renderer import PrinterRenderer
from printerm.templates.template_manager import TemplateManager

logger = logging.getLogger(__name__)


def prepare_template_context(
    template_manager: TemplateManager, template_name: str, user_context: dict[str, Any]
) -> dict[str, Any]:
    """
    Prepare complete template context by combining user-provided variables with script-generated ones.

    Args:
        template_manager: The template manager instance
        template_name: Name of the template
        user_context: User-provided context variables

    Returns:
        Complete context with both user and script variables
    """
    # Start with user context
    context = user_context.copy()

    # Try to get script variables
    script_func = template_manager.get_template_script(template_name)
    if script_func:
        try:
            # Execute the script to get pre-computed variables
            script_vars = script_func()
            # Only add script variables that aren't already in context
            for key, value in script_vars.items():
                if key not in context:
                    context[key] = value
            logger.debug(f"Applied script variables for template '{template_name}'")
        except Exception as e:
            logger.error(f"Error executing script for template '{template_name}': {e}", exc_info=True)

    return context


class TemplateRenderer:
    """
    Renders templates with context, handling Markdown formatting,
    text wrapping, and special character processing.
    """

    def __init__(self, template_manager: TemplateManager) -> None:
        self.template_manager = template_manager
        self.reload_settings()
        logging.debug("Initialized TemplateRenderer.")

    def reload_settings(self) -> None:
        """
        Reload settings from the configuration.
        """
        self.chars_per_line = get_chars_per_line()
        self.enable_special_letters = get_enable_special_letters()
        logging.debug("TemplateRenderer settings reloaded.")

    def render_from_template(self, template_name: str, context: dict[str, Any]) -> list[dict[str, Any]]:
        """
        Render the template with context, handling markdown formatting and special characters.
        """
        template = self.template_manager.get_template(template_name)
        if not template:
            raise ValueError(f"Template '{template_name}' not found.")

        # Get complete context with script variables
        complete_context = prepare_template_context(self.template_manager, template_name, context)

        segments = template.get("segments", [])
        rendered_segments = []
        env = Environment(loader=BaseLoader(), autoescape=True, keep_trailing_newline=True)

        for segment in segments:
            template_text = segment["text"]
            jinja_template = env.from_string(template_text)
            try:
                text = jinja_template.render(**complete_context)
            except Exception as e:
                logger.error(f"Error rendering template '{template_name}': {e}")
                raise

            if not self.enable_special_letters:
                logger.debug("Transliterating text to ASCII")
                text = unidecode(text)

            if segment.get("markdown", False):
                # Use Mistune to parse markdown and render segments
                renderer = PrinterRenderer(self.chars_per_line)
                markdown = Markdown(renderer=renderer)
                markdown(text)

                # Process the segments generated by the renderer
                for seg in renderer.segments:
                    wrapped_text = textwrap.fill(
                        seg["text"], width=self.chars_per_line, replace_whitespace=False, drop_whitespace=False
                    )
                    styles = seg.get("styles", {})
                    rendered_segments.append({"text": wrapped_text, "styles": styles})
            else:
                wrapped_text = textwrap.fill(
                    text, width=self.chars_per_line, replace_whitespace=False, drop_whitespace=False
                )
                rendered_segments.append({"text": wrapped_text, "styles": segment.get("styles", {})})

        return rendered_segments


def get_latest_version() -> str:
    """Get the latest version of printerm from PyPI."""
    url = "https://pypi.org/pypi/printerm/json"
    try:
        response = requests.get(url, timeout=5)
        if response.status_code == 200:
            data = response.json()
            return data["info"]["version"]
        else:
            logger.warning(f"Failed to fetch the latest version from PyPI: {response.status_code}")
            raise RuntimeWarning("Failed to fetch the latest version from PyPI.")
    except Exception as e:
        logger.error(f"Error while fetching latest version: {e}")
        raise RuntimeWarning(f"Failed to fetch the latest version from PyPI: {e}") from e


def is_new_version_available(current_version: str) -> bool:
    """Check if a newer version is available on PyPI."""
    try:
        latest_version = get_latest_version()
        return version.parse(latest_version) > version.parse(current_version)
    except Exception as e:
        logger.error(f"Error checking for updates: {e}")
        return False
